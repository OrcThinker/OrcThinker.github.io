<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>OrcThinker | Geekier every day</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <meta name="description" content="" />
  <link rel="stylesheet" type="text/css" href="stylesheets/site.css" />
  <link rel="icon" href="images/orcThinkerIcon.png" />
</head><body>
  <nav class="web-nav">
    <div class="website-logo">
<a href="./">
        <b>OrcThinker's</b> Geekier every day
      </a>
    </div>
    <ul>
      <li>
<a href="./">Home</a>
      </li>
      <li>
<a href="./blog">Blog</a>
      </li>
    </ul>
  </nav>
  <div class="main-container">
 <div class="post-container">
<h1>Isometric Map</h1><p>In this article we are going to go over what is isometric perspective, why do we love it and how to implement it using odin lang. We are going to go over basic math and rendering textures and to finish it off we are going to check out how to make a simple animation with them.</p><h2> Isometric perspective?</h2><p>We all like the isometric projection. Many of the games we loved and the games we still love use it. It is still a good way to fake a 3D effect using 2D textures.</p><p>I've decided to give it a go and try to write code a little isometric tiling system by myself and I'd like to share how I did it and how one codes animation like this one.</p><img src="./IsometricMap/tilesAnimationCropped.gif"/><p>Also I'll do it without using matrices and try to keep it very simple.</p><h2> Understanding isometric tiling</h2><p>First and foremost we need to understand how the graphics library we will be using works. Each pixel is being drawn seperately and is based on x and y axis.</p><img src="./IsometricMap/Cartesian.png"/><p>The x axis grows by 1 value when we move to the right and the y axis grows by a value of 1 when we move towards the bottom of the screen.</p><p>Keeping that in mind we just have to find a way to translate this "Screen space" to the space we want "Isometric space".</p><p>To do that let's take a look at the basic isometric coordinate system.</p><img src="./IsometricMap/BasicIsoCoords.png"/><p>In the picture above we have 4 colored entities. The background line is representing a cartesian system (our "Screen space"), and the three colored arrows represend the 3 dimensions that we want to display.</p><p>Now we have 2 axes isoX and isoY that allow us to traverse the ground (tiles) on a certain height they are at. The isoZ axis represents that height, so how high the tile is.</p><p>The simplest, most popular idea is that both 1 unit for isoX and isoY axes have the same length and height on our "Screen space".</p><p>For now let's take a look at those 2 axes and how a tile would look.</p><img src="./IsometricMap/XYtile.png"/><p>As you can see if we create a lines that mirror isoY and IsoX we get a singular tile.</p><p>Now we can move a new tile along the isoX axis.</p><img src="./IsometricMap/XYtileMovedX.png"/><p>As seen on the image if we create a tile that is moved 1 unit along the isoX axis then the tile will move to the bottom right.</p><p>The value of x on our "Screen space" will increase by half the tiles width and y by the half of the tiles height (remember screens y axis is facing bottom of the screen).</p><p>For the isoY axis</p><img src="./IsometricMap/XYtileMovedY.png"/><p>Here the situation is similar. The "Screen space" y value increases by half the tiles height however the x value is facing the other direction thus x value decreases by half the tiles width</p><p>With this knowledge we can create a simple tiling system and recognize the tiles placement like so.</p><img src="./IsometricMap/XYtiles.png"/><p>With that out the way we know most of what we will need to code the system but to finish up with the neccessary knowledge we will add isoZ axis into the mix.</p><p>IsoZ axis will allow us to manipulate height but it wouldn't be any good unless we change our flat tile into a 3D tile that incorporates all dimensions.</p><img src="./IsometricMap/XYtileHeight.png"/><p>Just adding the height to the mix changes our flat tile into a cuboid. For the isoZ axis we will assume that 1 unit will be moving our tile upwards by 1 "levelHeight" that is present in the image above.</p><img src="./IsometricMap/XYtilesZ.png"/><p>Now we can have 2 tiles that are directly on top of each other. And the tile that is higher has a higher isoZ value. Also observing this image we can conclude that moving a tile "up" along isoZ axis only changes our tile position on "Screen space" on the y axis and it does so by levelHeight. For this particular example we took levelHeight to be half the tiles height but it can be whatever you would like your tile height to be.</p><p>With that out the way the only thing left is to translate this information to code.</p><h2> Coding it up</h2><p>Now we have the knowhow of how the isometric tiling works. We just need to translate our "Screen space" location (pixel x,y values) to isometric position (isoX, isoY, isoZ) and then translate it back to iso space.</p><p>I'll be using Odin lang and raylib for coding. The language is simple and functions should be descriptive enough. The most important thing that may not be obvious is that ":=" (can be ":type=value") is declaration whereas "=" is assignment.</p><h2> Isometric to screen</h2><p>First let's take a look at how we will translate isometric position to "Screen space"</p><p>What we know so far is that we have 3 variables isoX, isoY and isoZ.</p><p>To get our screens x value we need to combine the knowledge of how each of those variables affect it</p><p>increase in isoX = +tileWidth/2, increase in isoY = -tileWidth/2, increase in isoZ = no effect</p><p>Thus</p><p>x = isoX * tileWidth/2 - isoY * tileWidth/2</p><p>x = (isoX - isoY) * tileWidth/2</p><p>We will be using struct tileSize. Where tileSize.x represents width and tileSize.y represents height, so</p><p>x = (isoX - isoY) * tileSize.x/2</p><p>Now analyze screen y value based on iso position variables</p><p>increase in isoX = +tileHeight/2, increase in isoY = +tileHeight/2, increase in isoZ = -levelHeight (which we decided in this program will be tileHeight/2)</p><p>y = isoX * tileHeight/2 + isoY * tileHeight/2 - isoZ * levelHeight</p><p>y = isoX * tileHeight/2 + isoY * tileHeight/2 - isoZ * tileHeight/2</p><p>y = (isoX + isoY - isoZ) * tileHeight/2</p><p>y = (isoX + isoY - isoZ) * tileSize.y/2</p><img src="./IsometricMap/IsoCoordToScreen.png"/><h2> Screen to isometric coordinates</h2><p>This one is created by simple reversing the previous one.</p><p>Math</p><p>X part of equasion:</p><p>x = (isoX - isoY) * tileSize.x/2</p><p>x / tileSize.x * 2 = isoX - isoY</p><p>(x / tileSize.x * 2) + isoY = isoX</p><p>isoX = (x / tileSize.x * 2) + isoY</p><p>Y part (here we need isoY value to substitute it to calculate isoX):</p><p>y = (isoX + isoY - isoZ) * tileSize.y/2</p><p>y / tileSize.y * 2 = isoX + isoY - isoZ</p><p>(y / tileSize.y * 2) - isoX + isoZ = isoY</p><p>isoY = (y / tileSize.y * 2) - isoX + isoZ</p><p>Back to isoX:</p><p>isoX = (x / tileSize.x * 2) + isoY</p><p>isoX = (x / tileSize.x * 2) + (y / tileSize.y * 2) - isoX + isoZ</p><p>2 * isoX = (x / tileSize.x * 2) + (y / tileSize.y * 2) + isoZ</p><p>isoX = ((x / tileSize.x * 2) + (y / tileSize.y * 2) + isoZ)/2</p><p>We have the isoX and isoY and this is how it looks in code</p><img src="./IsometricMap/ScreenToIsoCoord.png"/><h2> Setting up our "game" playground</h2><p>Now that we have those 2 functions let's play abit with them and see how they work. Next step we would need is to be able to know what tile is under our mouse position so that we can verify that functions work properly.</p><p>To get to that first we have to create a odin program with a basic raylib window display.</p><p>At first we will create some structs and initialize programs start</p><img src="./IsometricMap/odinSetup1.png"/><p>Then we need to create a raylib window and create a loop that will render our frames</p><img src="./IsometricMap/odinSetup2.png"/><p>This should be enough to display a window with our targetFps.</p><p>To run program you have to run "odin run ." in the programs folder (for more info see odin-lang website).</p><h2> Applying isometric functions</h2><p>Now that we have some graphics we can plug in our previously written traslation functions.</p><img src="./IsometricMap/odinSetupMouseIso.png"/><p>First of all we want to get our "Screen space" position of mouse and to get that we use rl.GetMousePosition() and will will render it at the top of the screen with rl.DrawText().</p><p>Next we translate this position to isometric coordinates using ScreenToIsoCoord() we have written.</p><p>We need to offest the position by the origin of the tile (it's center) so we do "- tileSize.x/2"</p><p>We draw this value onto the screen with rl.DrawText() get this.</p><img src="./IsometricMap/MousePos.png"/><p>Here we see that pixel with coords (509, 372) translates to isoX = 19 and isoY = 4 and thats around the middle so let's draw a tile there</p><p>To draw a tile we will need some tiles to render. I've already created some but feel free to create your own. Those are my tiles.</p><img src="./IsometricMap/shortTiles.png"/><p>I've split the tiles grid lines from the actual tile. You will later see why</p><p>Onto the texture drawing</p><img src="./IsometricMap/RenderTile.png"/><p>This one is a bit packed. I've added few things we may want later on.</p><p>RenderTile function takes 5 parameters:</p><p>pos - position where it should be rendered</p><p>tileTexture - texture file it'll be using</p><p>textureNr - which texture from texture file we want to use. Default is first one that is not grid</p><p>renderWithGrid - whether we want to draw grid around it</p><p>highlighted - whether we want to highlight the tile (will be useful for mouse over later on)</p><p>The function is self descriptive.</p><p>First we locate where in the texture file we will have our tile. Then we get rectangle that represend the whole texture placement. If the tile is to be highlighted we will change it's color abit. now we draw the tile texture with rl.DrawTextureRec(). If we want grid lines around tile we use renderWithGrid flag set to true.</p><p>In our game() function we call the renderTile for a position that we want to render it in.</p><img src="./IsometricMap/render1Tile.png"/><p>Run our app with "odin run ." and see what happens.</p><img src="./IsometricMap/render1TileImage.png"/><p>And so we've got our first tile.</p><p>Now let's add one more tile and see whether we can get a highlight to work when we mouse over the tile.</p><p>To also see whether the grid drawing works we will change the renderWithGrid flag to false in function call. So replace the tile render code to make it look like the following</p><img src="./IsometricMap/render2Tiles.png"/><p>When when we run the code we should be able to see 2 tiles that change color when we mouse over them</p><img src="./IsometricMap/render2TilesImage.png"/><p>Ok now that we've got it working let's make more tiles with a for loop and we will have ourselves a basic tiling system with a whole floor. So let's change tile render code to following one</p><img src="./IsometricMap/renderManyTiles.png"/><p>And run the code to see whether we have a small floor of tiles we can mouse over</p><img src="./IsometricMap/renderManyTilesImage.png"/><p>And we've got it. Now to not make it an empty promise I'll show you how to make the animation from the start</p><h2> The animation</h2><p>The animation is actually a expansion of what we have written with a bit of isoZ and sin() func.tion</p><p>We are going to simply add few floors and make them move along the lines of the sin() function. As you may remember we've already implemented isoZ into our functions however we always called them with a static value of isoZ. Now let's just add another floor (in a very "non clean code" way). So let's rewrite our render code yet again.</p><img src="./IsometricMap/render2Levels.png"/><p>Run it.</p><img src="./IsometricMap/render2LevelsImage.png"/><p>And so we now have a proof that our code can render many levels. Now we are going to render few levels along the sinusoid.</p><img src="./IsometricMap/renderSinLevels.png"/><p>Instead of doing another loop we just render them 1 by 1. Fell free to play around with those and maybe even refactor it with a "z-index loop".</p><p>Few key things we need to know before we understand the implementation. sin() functions or Sines y value reaches 0 every PI. So we need to make it so that all of our tiles have height based on sin() and make it fairly smooth. In the code above you can see "rippleSize" it basically indicates how many tiles we need to reach peak and valley of the sine. We need to simply take the sin() value based on x times the PI divided by how big we want the ripple to be. rippleHeight is a multiplier we are going to use to adjust the height change caused by sin() value of our x.</p><p>And it will give us this</p><img src="./IsometricMap/renderSinLevelsImage.png"/><p>And now the final piece. We are going to use sinIter (you may have seen it in our setup steps for raylib and odin at the very beginning of coding section). Now in the game loop we will increment sinIter's value.</p><p>sinIter += 1</p><p>And include it in our render function like so</p><img src="./IsometricMap/renderSinLevelsAnimated.png"/><p>Now we've added animationSpeed into the mix which we need to include into our sin() value calculation. By simply moving each tile by a bit based on sinIter we will animate the wave. Now run the code for the one last time.</p><p>To have the same effect as at the beginning remove text drawing (rl.DrawText() calls)</p><img src="./IsometricMap/tilesAnimationCropped.gif"/><h2> Summary</h2><p>This was a introduction to tiling and I hope anyone who read it gets something from this brief tutorial. I would highly recommend to see the video version of this one.</p><p>I'll most likely be doing another post for isometric tiling where we will be Creating and Deleting tiles allowing us to create our own maps.</p><p>If you'd like to see the code:</p><ul><li><a href=" https://github.com/OrcThinker/IsometricOdinGuide/tree/end1anim"> https://github.com/OrcThinker/IsometricOdinGuide/tree/end1anim</a></li>
</div>

  </div>
</body>
</html>
